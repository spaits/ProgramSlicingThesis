[kernel] Parsing tiny-jsonModEntryNoHeaders.c (with preprocessing)
[eva] Analyzing a complete application starting at objValue
[eva:initial-state] Values of globals at initialization
  errno ∈ {42}
  blank ∈ {{ " \n\r\t\012" }}
  endofblock ∈ {{ "}]" }}
[eva:alarm] tiny-jsonModEntryNoHeaders.c:452: Warning: 
  out of bounds read. assert \valid_read(&obj->type);
[eva:alarm] tiny-jsonModEntryNoHeaders.c:453: Warning: 
  out of bounds read. assert \valid_read(ptr);
[eva:alarm] tiny-jsonModEntryNoHeaders.c:546: Warning: 
  out of bounds read. assert \valid_read(str);
[eva:alarm] tiny-jsonModEntryNoHeaders.c:547: Warning: 
  out of bounds read. assert \valid_read(str);
[eva] tiny-jsonModEntryNoHeaders.c:535: starting to merge loop iterations
[eva] tiny-jsonModEntryNoHeaders.c:546: starting to merge loop iterations
[eva:alarm] tiny-jsonModEntryNoHeaders.c:462: Warning: 
  out of bounds read. assert \valid_read(ptr);
[eva:alarm] tiny-jsonModEntryNoHeaders.c:466: Warning: 
  out of bounds read. assert \valid_read(ptr);
[eva:alarm] tiny-jsonModEntryNoHeaders.c:467: Warning: 
  out of bounds write. assert \valid(ptr);
[eva:alarm] tiny-jsonModEntryNoHeaders.c:476: Warning: 
  out of bounds read. assert \valid_read(&pool->alloc);
[eva:alarm] tiny-jsonModEntryNoHeaders.c:476: Warning: 
  pointer to function with incompatible type.
  assert \valid_function(pool->alloc);
[eva] tiny-jsonModEntryNoHeaders.c:459: starting to merge loop iterations
[scope:rm_asserts] removing 2 assertion(s)
[eva] ====== VALUES COMPUTED ======
[eva:final-states] Values at end of function isOneOfThem:
  set ∈ {{ " \n\r\t\012" + {1; 2; 3; 4; 5} }}
  __retres ∈ {0; 1}
[eva:final-states] Values at end of function goWhile:
  str ∈ {{ &S_ptr[1] }}
  __retres ∈ {{ NULL ; &S_ptr[1] }}
[eva:final-states] Values at end of function goBlank:
  
[eva:final-states] Values at end of function objValue:
  ptr ∈ {{ NULL ; &S_ptr[2] }}
  endchar ∈ {93; 125}
  parentObj ∈ {0} or UNINITIALIZED
  property ∈ UNINITIALIZED
  __retres ∈ {{ NULL ; &S_ptr[2] }}
  S_obj[0].sibling ∈ {0}
       [0].name ∈ {{ NULL ; &S_name_0_S_obj[0] }}
       [0].u{.value; .c.child} ∈ {0}
       [0].u{.value[bits 64 to 127]; .c.last_child} ∈
       {{ garbled mix of &{WELL_u_0_S_obj} (origin: Well) }}
       [0].type ∈ {JSON_OBJ; JSON_ARRAY}
       [0].[bits 288 to 319] ∈ UNINITIALIZED
       [1].sibling ∈ {{ NULL ; &S_sibling_1_S_obj[0] }}
       [1].name ∈ {{ NULL ; &S_name_1_S_obj[0] }}
       [1].u ∈ {{ garbled mix of &{WELL_u_1_S_obj} (origin: Well) }}
       [1].type ∈ [--..--]
       [1].[bits 288 to 319] ∈ UNINITIALIZED
  S_ptr[0..1] ∈ [--..--]
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  4 functions analyzed (out of 33): 12% coverage.
  In these functions, 57 statements reached (out of 106): 53% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  9 alarms generated by the analysis:
       8 invalid memory accesses
       1 other
  ----------------------------------------------------------------------------
  No logical properties have been reached by the analysis.
  ----------------------------------------------------------------------------
[slicing] slicing requests in progress...
[slicing] initializing slicing ...
[slicing] interpreting slicing requests from the command line...
[slicing] Nothing to select for an unreachable stmt of objValue
[pdg] computing for function objValue
[from] Computing for function goBlank
[from] Computing for function goWhile <-goBlank
[from] Computing for function isOneOfThem <-goWhile <-goBlank
[from] Done for function isOneOfThem
[from] Done for function goWhile
[from] Done for function goBlank
[pdg] tiny-jsonModEntryNoHeaders.c:476: Warning: 
  not implemented by pdg yet: pdg with an unknown function call: /*@ assert Eva: mem_access: \valid_read(&pool->alloc); */
  /*@ assert Eva: function_pointer: \valid_function(pool->alloc); */
  property = (*(pool->alloc))(pool);
[pdg] Top for function objValue
[slicing] applying all slicing requests...
[slicing] applying 0 actions...
[slicing] applying all slicing requests...
[slicing] applying 1 actions...
[slicing] applying actions: 1/1...
[slicing] unable to slice objValue (-> TOP)
[slicing] exporting project to 'Slicing export'...
[slicing] applying all slicing requests...
[slicing] applying 0 actions...
[sparecode] remove unused global declarations from project 'Slicing export tmp'
[sparecode] removed unused global declarations in new project 'Slicing export'
/* Generated by Frama-C */
enum __anonenum_jsonType_t_1 {
    JSON_OBJ = 0,
    JSON_ARRAY = 1,
    JSON_TEXT = 2,
    JSON_BOOLEAN = 3,
    JSON_INTEGER = 4,
    JSON_REAL = 5,
    JSON_NULL = 6
};
typedef enum __anonenum_jsonType_t_1 jsonType_t;
struct __anonstruct_c_3 {
   struct json_s *child ;
   struct json_s *last_child ;
};
union __anonunion_u_2 {
   char const *value ;
   struct __anonstruct_c_3 c ;
};
struct json_s {
   struct json_s *sibling ;
   char const *name ;
   union __anonunion_u_2 u ;
   jsonType_t type ;
};
typedef struct json_s json_t;
struct jsonPool_s;
typedef struct jsonPool_s jsonPool_t;
struct jsonPool_s {
   json_t *(*init)(jsonPool_t *pool) ;
   json_t *(*alloc)(jsonPool_t *pool) ;
};
char *goBlank(char *str);

char *objValue_orig(char *ptr, json_t *obj, jsonPool_t *pool);

char *objValue_orig(char *ptr, json_t *obj, jsonPool_t *pool)
{
  char *__retres;
  char endchar;
  char c;
  json_t *parentObj;
  json_t *property;
  if (obj->type == (unsigned int)JSON_OBJ) endchar = (char)'}';
  else endchar = (char)']';
  if ((int)*ptr == '{') obj->type = JSON_OBJ; else obj->type = JSON_ARRAY;
  obj->u.c.child = (struct json_s *)0;
  obj->sibling = (struct json_s *)0;
  ptr ++;
  while (1) {
    ptr = goBlank(ptr);
    if (! ptr) {
      __retres = (char *)0;
      goto return_label;
    }
    if ((int)*ptr == ',') {
      ptr ++;
      goto __Cont;
    }
    if ((int)*ptr == (int)endchar) {
      *ptr = (char)'\000';
      parentObj = obj->sibling;
      if (! parentObj) {
        ptr ++;
        __retres = ptr;
        goto return_label;
      }
      obj->sibling = (struct json_s *)0;
      obj = parentObj;
      ptr ++;
      goto __Cont;
    }
    property = (*(pool->alloc))(pool);
    if (! property) {
      __retres = (char *)0;
      goto return_label;
    }
    if (obj->type != (unsigned int)JSON_ARRAY) {
      if ((int)*ptr != '\"') {
        __retres = (char *)0;
        goto return_label;
      }
      ptr = propertyName(ptr,property);
      if (! ptr) {
        __retres = (char *)0;
        goto return_label;
      }
    }
    else property->name = (char const *)0;
    add(obj,property);
    property->u.value = (char const *)ptr;
    switch ((int)*ptr) {
      case '{': property->type = JSON_OBJ;
      property->u.c.child = (struct json_s *)0;
      property->sibling = obj;
      obj = property;
      ptr ++;
      break;
      case '[': property->type = JSON_ARRAY;
      property->u.c.child = (struct json_s *)0;
      property->sibling = obj;
      obj = property;
      ptr ++;
      break;
      case '\"': ptr = textValue(ptr,property);
      break;
      case 't': ptr = trueValue(ptr,property);
      break;
      case 'f': ptr = falseValue(ptr,property);
      break;
      case 'n': ptr = nullValue(ptr,property);
      break;
      default: ptr = numValue(ptr,property);
      break;
    }
    if (! ptr) {
      __retres = (char *)0;
      goto return_label;
    }
    __Cont: ;
  }
  return_label: return __retres;
}

int isOneOfThem(char ch, char const *set)
{
  int __retres;
  while ((int)*set != '\000') {
    char const *tmp;
    tmp = set;
    set ++;
    if ((int)ch == (int)*tmp) {
      __retres = 1;
      goto return_label;
    }
  }
  __retres = 0;
  return_label: return __retres;
}

char *goWhile(char *str, char const *set)
{
  char *__retres;
  while ((int)*str != '\000') {
    {
      int tmp;
      tmp = isOneOfThem(*str,set);
      if (! tmp) {
        __retres = str;
        goto return_label;
      }
    }
    str ++;
  }
  __retres = (char *)0;
  return_label: return __retres;
}

char const * const blank = " \n\r\t\f";
char *goBlank(char *str)
{
  char *tmp;
  tmp = goWhile(str,blank);
  return tmp;
}


